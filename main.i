# 1 "main.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 415 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "main.cpp" 2

# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 1
# 40 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../../c/stdinc.h" 1
# 27 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../../c/stdinc.h"
extern "C" {




# 1 "../../../../../SVGN/unisym/inc/c/proctrl.h" 1
# 12 "../../../../../SVGN/unisym/inc/c/proctrl.h"
# 1 "../../../../../SVGN/unisym/inc/c/uoption.h" 1
# 13 "../../../../../SVGN/unisym/inc/c/proctrl.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/floating.h" 1
# 36 "../../../../../SVGN/unisym/inc/c/floating.h"
# 1 "../../../../../SVGN/unisym/inc/c/integer.h" 1
# 36 "../../../../../SVGN/unisym/inc/c/integer.h"
# 1 "../../../../../SVGN/unisym/inc/c/archit.h" 1
# 28 "../../../../../SVGN/unisym/inc/c/archit.h"
enum Architecture_t
{
 Architecture_x86,
 Architecture_RISCV64,

 Architecture_x86_64,

 Architecture_ARM,
 Architecture_ARM64,
 Architecture_MIPS,
 Architecture_MIPS64,
 Architecture_RISCV32,
 Architecture_POWERPC64,
 Architecture_POWERPC32,
 Architecture_SPARC64,
 Architecture_SPARC32,

 Architecture_Unknown
};
# 164 "../../../../../SVGN/unisym/inc/c/archit.h"
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 1 3
# 106 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 1 3
# 26 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
# 700 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
namespace std { inline namespace __2 { }}
# 107 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 2 3
# 110 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 123 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 1 3
# 40 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
      namespace std {

          extern "C" {
# 56 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;


typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;





typedef signed char int_least8_t;
typedef signed short int int_least16_t;
typedef signed int int_least32_t;
typedef signed long long int int_least64_t;


typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long int uint_least64_t;




typedef signed int int_fast8_t;
typedef signed int int_fast16_t;
typedef signed int int_fast32_t;
typedef signed long long int int_fast64_t;


typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long int uint_fast64_t;






typedef signed int intptr_t;
typedef unsigned int uintptr_t;



typedef signed long long intmax_t;
typedef unsigned long long uintmax_t;
# 268 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
         }
      }





      using ::std::int8_t;
      using ::std::int16_t;
      using ::std::int32_t;
      using ::std::int64_t;
      using ::std::uint8_t;
      using ::std::uint16_t;
      using ::std::uint32_t;
      using ::std::uint64_t;
      using ::std::int_least8_t;
      using ::std::int_least16_t;
      using ::std::int_least32_t;
      using ::std::int_least64_t;
      using ::std::uint_least8_t;
      using ::std::uint_least16_t;
      using ::std::uint_least32_t;
      using ::std::uint_least64_t;
      using ::std::int_fast8_t;
      using ::std::int_fast16_t;
      using ::std::int_fast32_t;
      using ::std::int_fast64_t;
      using ::std::uint_fast8_t;
      using ::std::uint_fast16_t;
      using ::std::uint_fast32_t;
      using ::std::uint_fast64_t;
      using ::std::intptr_t;
      using ::std::uintptr_t;
      using ::std::intmax_t;
      using ::std::uintmax_t;
# 124 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 2 3
# 165 "../../../../../SVGN/unisym/inc/c/archit.h" 2

# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 1 3
# 44 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 57 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\limits.h" 1 3
# 58 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 2 3
# 167 "../../../../../SVGN/unisym/inc/c/archit.h" 2

# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 1 3
# 43 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 3


# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 1 3
# 28 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
        namespace std {

        extern "C" {







  typedef signed int ptrdiff_t;







    typedef unsigned int size_t;
# 95 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
  typedef long double max_align_t;



         }
      }






      using ::std::size_t;
      using ::std::ptrdiff_t;

        using ::std::max_align_t;
# 46 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 2 3


    typedef decltype(nullptr) nullptr_t;
# 169 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 277 "../../../../../SVGN/unisym/inc/c/archit.h"
# 1 "../../../../../SVGN/unisym/inc/c/alice.h" 1
# 35 "../../../../../SVGN/unisym/inc/c/alice.h"
typedef void* pureptr_t;
typedef void(*_tofree_ft)(pureptr_t);
typedef int(*_tocomp_ft)(pureptr_t, pureptr_t);
typedef void(symbol_t)(void);
# 54 "../../../../../SVGN/unisym/inc/c/alice.h"
extern "C++" {
 namespace uni {

  template<typename typed, typename types> inline static typed& cast(types& value) {
   return *(typed*)(&value);
  }
 }
}
# 278 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/call.h" 1
# 279 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/flag.h" 1
# 31 "../../../../../SVGN/unisym/inc/c/flag.h"
extern struct _aflag_t
{
 unsigned char carry : 1;
 unsigned char autosort : 1;
 unsigned char parity : 1;
 unsigned char signsym : 1;
 unsigned char auxiliary : 1;
 unsigned char one : 1;
 unsigned char zero : 1;
 unsigned char sign : 1;
 unsigned char debug : 1;
 unsigned char interrupt_enable : 1;
 unsigned char direction : 1;
 unsigned char overflow : 1;
 unsigned char io_privilege_level : 2;
 unsigned char nested_task : 1;
 unsigned char fail : 1;

 unsigned char resume : 1;
 unsigned char virtual_8086 : 1;
 unsigned char alignment_check : 1;
 unsigned char virtual_interrupt : 1;
 unsigned char virtual_interrupt_pending : 1;
 unsigned char identification : 1;
 unsigned char : 2;
 unsigned char : 8;
} aflaga;
# 280 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 37 "../../../../../SVGN/unisym/inc/c/integer.h" 2
# 72 "../../../../../SVGN/unisym/inc/c/integer.h"
typedef unsigned char byte;
typedef unsigned char uint8;
typedef signed char sint8;
typedef int8_t int8;
typedef signed char sbyte;
typedef uint16_t word;
typedef uint16_t uint16;
typedef int16_t sint16;
typedef int16_t int16;
typedef int16_t sword;
typedef uint32_t dword;
typedef uint32_t uint32;
typedef int32_t sint32;
typedef int32_t int32;
typedef int32_t sdword;

 typedef uint64_t qword;
 typedef uint64_t uint64;
 typedef int64_t sint64;
 typedef int64_t int64;
 typedef int64_t sqword;



typedef size_t stduint;
typedef ptrdiff_t stdint ;
typedef ptrdiff_t stdsint;

static const pureptr_t None = (pureptr_t)~(stduint)0;
# 37 "../../../../../SVGN/unisym/inc/c/floating.h" 2






inline static double CastF64FromU0(stduint i) {

 return (double)i;
}
# 14 "../../../../../SVGN/unisym/inc/c/proctrl.h" 2


enum Procontroller_t
{
 PCU_Intel8086,
 PCU_AMD_Ryzen7_5800H_Radeon,

 PCU_Unknown
};
# 45 "../../../../../SVGN/unisym/inc/c/proctrl.h"
 typedef uint32 typedest;
 typedef uint32 typeaddr;
# 33 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../../c/stdinc.h" 2


}
# 41 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 1
# 26 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../unisym" 1
# 26 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../unisym"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 27 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../unisym" 2

# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 29 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../unisym" 2
# 27 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 1
# 23 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h"
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 1 3
# 242 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 251 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 1 3
# 222 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
typedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;



extern "C" {


__attribute__((__nothrow__)) intmax_t strtoimax(const char * __restrict ,
                   char ** __restrict , int ) __attribute__((__nonnull__(1)));

__attribute__((__nothrow__)) uintmax_t strtoumax(const char * __restrict ,
                    char ** __restrict , int ) __attribute__((__nonnull__(1)));


__attribute__((__nothrow__)) intmax_t wcstoimax(const wchar_t * __restrict ,
                   wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));
__attribute__((__nothrow__)) uintmax_t wcstoumax(const wchar_t * __restrict ,
                    wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));

extern __attribute__((__nothrow__)) __attribute__((__const__)) intmax_t imaxabs(intmax_t );





extern __attribute__((__nothrow__)) __attribute__((__const__)) imaxdiv_t imaxdiv(intmax_t , intmax_t );
# 263 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
}
# 252 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 2 3
# 28 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h" 2
# 44 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h"
size_t BitReflect(size_t times, size_t val);


uint64_t BitReflect64(size_t times, uint64_t val);
# 25 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2
# 28 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../reference" 1
# 13 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../reference"
namespace uni {

 class Reference {
  volatile typedest* address;
 public:
  Reference(typeaddr address) : address((volatile typedest*)address) {

  }

  operator typedest() const { return *address; }
  volatile typedest* operator&() const { return address; }

  Reference& operator=(typedest val) { *address = val; return *this; }
  Reference& operator&=(typedest val) { *address &= val; return *this; }
  Reference& operator|=(typedest val) { *address |= val; return *this; }
  Reference& operator^=(typedest val) { *address ^= val; return *this; }

  bool bitof(stduint idx) const { return *address & (1 << idx); }

  void setof(stduint idx, bool val = true) { if (val) *address |= (1 << idx); else rstof(idx); }

  void rstof(stduint idx) { *address &= ~(typedest)(1 << idx); }
 };
}
# 29 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 1
# 27 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt"
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h" 1
# 25 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
typedef void (*Handler_t)(void);
# 214 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
typedef enum {

 IRQ_NonMaskableInt = -14,
 IRQ_MemoryManagement = -12,
 IRQ_BusFault = -11,
 IRQ_UsageFault = -10,
 IRQ_SVCall = -5,
 IRQ_DebugMonitor = -4,
 IRQ_PendSV = -2,
 IRQ_SysTick = -1,

 IRQ_WWDG = 0,
 IRQ_PVD = 1,
 IRQ_TAMP_STAMP = 2,
 IRQ_RTC_WKUP = 3,
 IRQ_FLASH = 4,
 IRQ_RCC = 5,
 IRQ_EXTI0 = 6,
 IRQ_EXTI1 = 7,
 IRQ_EXTI2 = 8,
 IRQ_EXTI3 = 9,
 IRQ_EXTI4 = 10,
 IRQ_DMA1_Stream0 = 11,
 IRQ_DMA1_Stream1 = 12,
 IRQ_DMA1_Stream2 = 13,
 IRQ_DMA1_Stream3 = 14,
 IRQ_DMA1_Stream4 = 15,
 IRQ_DMA1_Stream5 = 16,
 IRQ_DMA1_Stream6 = 17,
 IRQ_ADC = 18,
 IRQ_CAN1_TX = 19,
 IRQ_CAN1_RX0 = 20,
 IRQ_CAN1_RX1 = 21,
 IRQ_CAN1_SCE = 22,
 IRQ_EXTI9_5 = 23,
 IRQ_TIM1_BRK_TIM9 = 24,
 IRQ_TIM1_UP_TIM10 = 25,
 IRQ_TIM1_TRG_COM_TIM11 = 26,
 IRQ_TIM1_CC = 27,
 IRQ_TIM2 = 28,
 IRQ_TIM3 = 29,
 IRQ_TIM4 = 30,
 IRQ_I2C1_EV = 31,
 IRQ_I2C1_ER = 32,
 IRQ_I2C2_EV = 33,
 IRQ_I2C2_ER = 34,
 IRQ_SPI1 = 35,
 IRQ_SPI2 = 36,
 IRQ_USART1 = 37,
 IRQ_USART2 = 38,
 IRQ_USART3 = 39,
 IRQ_EXTI15_10 = 40,
 IRQ_RTC_Alarm = 41,
 IRQ_OTG_FS_WKUP = 42,
 IRQ_TIM8_BRK_TIM12 = 43,
 IRQ_TIM8_UP_TIM13 = 44,
 IRQ_TIM8_TRG_COM_TIM14 = 45,
 IRQ_TIM8_CC = 46,
 IRQ_DMA1_Stream7 = 47,
 IRQ_FSMC = 48,
 IRQ_SDIO = 49,
 IRQ_TIM5 = 50,
 IRQ_SPI3 = 51,
 IRQ_UART4 = 52,
 IRQ_UART5 = 53,
 IRQ_TIM6_DAC = 54,
 IRQ_TIM7 = 55,
 IRQ_DMA2_Stream0 = 56,
 IRQ_DMA2_Stream1 = 57,
 IRQ_DMA2_Stream2 = 58,
 IRQ_DMA2_Stream3 = 59,
 IRQ_DMA2_Stream4 = 60,
 IRQ_ETH = 61,
 IRQ_ETH_WKUP = 62,
 IRQ_CAN2_TX = 63,
 IRQ_CAN2_RX0 = 64,
 IRQ_CAN2_RX1 = 65,
 IRQ_CAN2_SCE = 66,
 IRQ_OTG_FS = 67,
 IRQ_DMA2_Stream5 = 68,
 IRQ_DMA2_Stream6 = 69,
 IRQ_DMA2_Stream7 = 70,
 IRQ_USART6 = 71,
 IRQ_I2C3_EV = 72,
 IRQ_I2C3_ER = 73,
 IRQ_OTG_HS_EP1_OUT = 74,
 IRQ_OTG_HS_EP1_IN = 75,
 IRQ_OTG_HS_WKUP = 76,
 IRQ_OTG_HS = 77,
 IRQ_DCMI = 78,
 IRQ_RNG = 80,
 IRQ_FPU = 81
} Request_t;
# 410 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
extern "C" {
 extern Handler_t FUNC_EXTI[];
 extern Handler_t FUNC_XART[8];
}
# 28 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 2




# 1 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 1
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 1
# 29 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 2
# 89 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/prochip/CortexM4.h" 1
# 31 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/prochip/CortexM4.h"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/prochip/_COM_CORTEX_M_3_4.h" 1






struct SysCtrlBlock_Map {
 uint32 CPUID;
 uint32 ICSR;
 uint32 VTOR;
 uint32 AIRCR;
 uint32 SCR;
 uint32 CCR;
 uint8 SHP[12U];
 uint32 SHCSR;
 uint32 CFSR;
 uint32 HFSR;
 uint32 DFSR;
 uint32 MMFAR;
 uint32 BFAR;
 uint32 AFSR;
 uint32 PFR[2U];
 uint32 DFR;
 uint32 ADR;
 uint32 MMFR[4U];
 uint32 ISAR[5U];
 uint32 RESERVED0[5U];
 uint32 CPACR;
};
# 32 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/prochip/CortexM4.h" 2
# 90 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 2

namespace uni {
 namespace NVICReg {
  typedef enum {
   ISER = 0x000 >> 2,
   ICER = 0x080 >> 2,
   ISPR = 0x100 >> 2,
   ICPR = 0x180 >> 2,
   IABR = 0x200 >> 2,
   IP0 = 0x300 >> 2,
   STIR = 0xE00 >> 2,
  } NVICReg;
 }

 class NVIC_t {
 public:
  Reference operator[](NVICReg::NVICReg idx) {
   return Reference(((0xE000E000UL) + 0x0100UL) + (((stduint)idx) << 2));
  }
  Reference Reflect(NVICReg::NVICReg idx, byte offs = 0) {
   return Reference(((0xE000E000UL) + 0x0100UL) + (((stduint)idx + offs) << 2));
  }
  SysCtrlBlock_Map* scbmap;
  uint32 getPriorityGroup();
  uint8* getTable(stduint idx = 0) { return ((uint8*)&(*this)[NVICReg::IP0]) + idx; }
  void setPriority(Request_t req, uint32 priority);
  void setPriority(Request_t req, uint32 prepriority, uint32 subpriority);
  void setAble(Request_t req, bool ena = true) {
   const stduint req_no = (stduint)req;
   if (!req_no) return;
   if (ena) {
    Reflect(NVICReg::ISER, req_no >> 5UL) = ((uint32_t)1 << (req_no & 0x1FUL));
   }
   else ;
  }

 };


 extern NVIC_t NVIC;
}
# 33 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 1
# 23 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2

# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI" 2


namespace uni {
# 52 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI"
 namespace GPIORupt {
  enum RuptEdge {
   Anyedge,
   Posedge,
   Negedge
  };
 }

 namespace GPIOEvent {
  enum EventEdge {
   OUT_PushPull = 0 << 2,
   Anyedge,
   Posedge,
   Negedge
  };
 }


 class EXTI {
 protected:

 public:
  static Reference MaskInterrupt;
  static Reference MaskEvent;
  static Reference TriggerRising;
  static Reference TriggerFalling;
  static Reference Softrupt;
  static Reference Pending;
 };


}
# 34 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 1
# 23 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2

# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../binary" 2
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO" 2


namespace uni {
# 50 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO"
 class SYSCFG {
 protected:

 public:
  static Reference MEMRM;
  static Reference PMC;
  static Reference ExternInterruptCfgs[4];
  static Reference CMPCR;

 };
 typedef SYSCFG AFIO;



}
# 35 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../interrupt" 2
# 30 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 2

extern "C" {
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/uctype.h" 1
# 55 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/uctype.h"
extern const unsigned char _tab_tolower[];
extern const unsigned char _tab_toupper[];
# 33 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO" 2
}
# 80 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO"
namespace uni {


 class GeneralPurposeInputOutputPin;
 class GeneralPurposeInputOutputPort;
# 152 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/GPIO"
 namespace GPIOMode {
  enum Mode {

   OUT_PushPull = 0x2,
   OUT_OpenDrain = 0x3,
   OUT_AF_PushPull = 0x4,
   OUT_AF_OpenDrain = 0x5,
   IN_Analog = 0x6,
   IN_Floating = 0x0,
   IN_Pull = 0x1,
   IN_KEPT
  };
 }
 namespace GPIOSpeed {
  enum Speed {
   Atmost_Low = 0,
   Atmost_Medium = 1,
   Atmost_High = 2,
   Atmost_Veryhigh = 3,
  };
 }
 namespace GPIOReg {
  typedef enum {
   MODER = 0, OTYPER, OSPEEDR, PUPDR,
   IDR, ODR, BSRR, LCKR,
   AFRL, AFRH
  } GPIOReg;
 }

 class GeneralPurposeInputOutputPin {
  protected: GeneralPurposeInputOutputPort* parent; uint32 bitposi; bool innput;
 public:
  GeneralPurposeInputOutputPin(GeneralPurposeInputOutputPort* parent = 0, uint32 bitposi = 0) : parent(parent), bitposi(bitposi), innput(true) {}
  bool getInn();
  void setMode(GPIORupt::RuptEdge edg);
  void setMode(GPIOEvent::EventEdge edg);
  void setPull(bool pullup);
  void setInterrupt(Handler_t fn);
  void setInterruptPriority(byte preempt, byte sub_priority);
  void enInterrupt(bool enable = true);
  bool isInput() const;





  void _set_alternate(byte selection);

  GeneralPurposeInputOutputPort& getParent() const; inline byte getID() const { return bitposi; } void setMode(GPIOMode::Mode mod, GPIOSpeed::Speed spd = GPIOSpeed::Atmost_Low, bool autoEnClk = true); void Toggle(); GeneralPurposeInputOutputPin& operator=(bool val); GeneralPurposeInputOutputPin& operator=(const GeneralPurposeInputOutputPin& pin); operator bool() const;
 };

 class GeneralPurposeInputOutputPort {
  stduint baseaddr;
  GeneralPurposeInputOutputPin OutpdPins[16];
  GeneralPurposeInputOutputPin ERR;
  uint32 EnablPosi;
 public:
  Reference ClockPort;
  Reference InnpdPort;
  Reference OutpdPort;

  Reference ModerPort;
  Reference OtypePort;
  Reference SpeedPort;
  Reference PullsPort;

  GeneralPurposeInputOutputPort(uint32 ADDR, uint32 CLK, uint32 Enap = 0);
  void enClock(bool enable = true) {
   (ClockPort) |= ((stduint)1 << EnablPosi);
  }
  GeneralPurposeInputOutputPin& operator[](uint8 pinid);
  Reference operator[](GPIOReg::GPIOReg trt) {
   return Reference(baseaddr + (((stduint)trt) << 2));
  }

  GeneralPurposeInputOutputPort& operator=(uint32 val);

  GeneralPurposeInputOutputPort& operator=(const GeneralPurposeInputOutputPort& pot); operator stduint() const;
 };

 extern GeneralPurposeInputOutputPort GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG;
 extern GeneralPurposeInputOutputPort GPIOH, GPIOI;





 struct GeneralPurposeInputOutput {
  GeneralPurposeInputOutputPort ERR;
  GeneralPurposeInputOutput() : ERR(~0, ~0, ~0) { }
  GeneralPurposeInputOutputPort& operator[](char portid);
  stduint Index(const GeneralPurposeInputOutputPort* port);
 };
 extern GeneralPurposeInputOutput GPIO;



 typedef GeneralPurposeInputOutputPin GPIO_Pin;
 typedef GeneralPurposeInputOutputPort GPIO_Port;
}
# 42 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC" 1
# 32 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCAddress" 1
# 33 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCClock" 1
# 38 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCClock"
namespace uni {
 namespace SysclkSource {
  enum RCCSysclockSource {
   HSI = 0x00000000,
   HSE = 0x00000004,
   PLL = 0x00000008,
   Unknown
  };
 }
}
# 162 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCClock"
namespace uni {


 class RCCSystemClock {
 protected:
  SysclkSource::RCCSysclockSource getSource();
  void setSource(SysclkSource::RCCSysclockSource source);
 public:
  RCCSystemClock() { }
        static SysclkSource::RCCSysclockSource CurrentSource();
  bool setMode(SysclkSource::RCCSysclockSource source = SysclkSource::PLL);
  stduint getFrequency();
 };


}
# 34 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCOscillator" 1
# 31 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCOscillator"
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCPLL" 1
# 107 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCPLL"
namespace uni {
 namespace PLLSource {
  enum PLLSource {
   HSI = 0x00000000,
   HSE = 0x00400000,
   Mask = HSE
  };
 }
 class RCCPLL {
 private:
  void enAble(bool ena = true);
 public:
  bool setMode();
  static bool isReady();
 };
}
# 32 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCOscillator" 2


namespace uni {
 namespace HSEState {
  enum RCCOscillatorHSEState {
   Disable = 0x00000000,
   Enable = (uint32)1 << 16,
   Bypass = ((uint32)1 << 18 | Enable),
  };
 }
}
# 131 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCOscillator"
namespace uni {
 class RCCOscillatorHSE
 {
 protected:
 public:
  bool setMode();
  static bool isReady();
 };
 typedef RCCOscillatorHSE HSE_t;

 class RCCOscillatorHSI
 {
 public:

  static bool isReady();
# 154 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCOscillator"
 };
 typedef RCCOscillatorHSI HSI_t;

}
# 35 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCPrescaler" 1
# 31 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCPrescaler"
namespace uni {
 class RCCPrescaler {

 };
# 72 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCCPrescaler"
 class RCCAHB : public RCCPrescaler {
 public:

  bool setMode(uint8 divexpo = 0, bool usingPCLK1 = true, bool usingPCLK2 = true);
 };

 class RCCAPB : public RCCPrescaler {
 protected:
  stduint PCLK_ID;
 public:
  RCCAPB(stduint PCLK_ID) : PCLK_ID((PCLK_ID - 1) & 1) {

  }

  bool setMode(uint8 divexpo);

  void enAble(uint8 bitposi) {
   Reference _RCC_APBxENR((PCLK_ID == 1) ? (0x40023800 + 0x44) :
    (0x40023800 + 0x40)
   );
   _RCC_APBxENR.setof(bitposi);
  }
 };



}
# 36 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC" 2
# 136 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/RCC/RCC"
namespace uni {

 extern uint32_t SystemCoreClock;
 extern const uint8_t AHBPrescTable[16];
 extern const uint8_t APBPrescTable[8];

 namespace RCCReg {
  typedef enum {
   CR = 0, PLLCFGR, CFGR, CIR,
   AHB1RSTR, AHB2RSTR, AHB3RSTR, REV00,
   APB1RSTR, APB2RSTR, REV01, REV02,
   AHB1ENR, AHB2ENR, AHB3ENR, REV03,
   APB1ENR, APB2ENR, REV04, REV05,
   AHB1LPENR, AHB2LPENR, AHB3LPENR, REV06,
   APB1LPENR, APB2LPENR, REV07, REV08,
   BDCR, CSR, REV09, REV10,
   SSCGR, PLLI2SCFGR
  } RCCReg;
 }

 class RCC_t {
 protected:
        byte getLatency() {
   Reference _FLASH_ACReg(0x40023C00);
   return (_FLASH_ACReg & 0x7);
  }
        void setLatency(byte FLatency) {
   FLatency &= 0x7;
   Reference _FLASH_ACReg(0x40023C00);
   _FLASH_ACReg = (_FLASH_ACReg & ~(0x7)) | FLatency;
  }
 public:
  RCCOscillatorHSE HSE;



  RCCPLL PLL;
  RCCSystemClock Sysclock;
  RCCAHB AHB;
  RCCAPB APB1, APB2;
  inline Reference operator[](RCCReg::RCCReg idx) { return Reference( 0x40023800 + (((stduint)idx) << 2)); }
  RCC_t() : APB1(1), APB2(2) {}
        bool setFlash(bool decrease = false) {
   stduint FLatency = 5;
   if ((FLatency > getLatency()) ^ decrease)
    setLatency(FLatency);
   return FLatency == getLatency();
  }
  bool setClock(SysclkSource::RCCSysclockSource source);




  stduint getFrequencyHCLK() {
   return SystemCoreClock;
  }
  stduint getFrequencyPCLK1();
  stduint getFrequencyPCLK2();


 };

 extern RCC_t RCC;
}
# 43 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/SysTick" 1
# 34 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/SysTick"
namespace uni {
 typedef struct SysTick_Map
 {
  uint32 CTRL;
  uint32 LOAD;
  uint32 VAL;
  uint32 CALIB;
 } SysTick_Map;
}
# 61 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/SysTick"
namespace uni {
 class SysTick {
 public:
  static bool enClock(uint32 Hz);
  static SysTick_Map& ref() { return *(SysTick_Map*)0xE000E010; }
 };
}



extern "C" void SysDelay(stduint unit);
# 44 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 2
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/UART" 1
# 1 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/driver/UART.h" 1
# 61 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/../../c/driver/UART.h"
namespace uni {
 namespace XARTReg {
  typedef enum {
   SR = 0, DR, BRR, CR1,
   CR2, CR3, GTPR
  } USARTReg;
 }




 class UART_t {
 protected:
  stduint baseaddr;
  byte XART_ID;
 public:
  UART_t(stduint _baseaddr, byte _XART_ID) : baseaddr(_baseaddr), XART_ID(_XART_ID) {}

 };

 class USART_t {
 protected:
  stduint baseaddr;
  byte XART_ID;
 public:
  Reference operator[](XARTReg::USARTReg idx) {
   return Reference(baseaddr + (((stduint)idx) << 2));
  }
  USART_t(stduint _baseaddr, byte _XART_ID) : baseaddr(_baseaddr), XART_ID(_XART_ID) {}

  void setMode( void);



  inline int operator>> (int& res) {
   using namespace XARTReg;
   bool len9b = false;
   bool parity = false;
   stduint mask = len9b ?
    (parity ? 0x1FF : 0xFF):
    (parity ? 0x0FF : 0x7F);
   int d = int((*this)[DR]);
   return res = d & mask;
  }



  inline USART_t& operator<< (stduint dat) {
   using namespace XARTReg;
   bool len9b = false;
   (*this)[DR] = dat & (len9b ? 0x1FF : 0x0FF);
   return (*this);
  }
  inline USART_t& operator<< (const char* p) {
   while (*p) {
    (*this) << stduint(*p++);
    for(size_t i=0, _LIMIT=(1000);i<(_LIMIT);i++);
   }
   return (*this);
  }

  bool enAble(bool ena = true) {
   using namespace XARTReg;
   (*this)[CR1].setof(13, ena);
   return true;
  }

  bool enClock(bool ena = true) {

   using namespace RCCReg;
   RCC[APB2ENR].setof(4, ena);
   return RCC[APB2ENR].bitof(4) == ena;
  }

  void setInterrupt(Handler_t fn);
  void setInterruptPriority(byte preempt, byte sub_priority);
  void enInterrupt(bool enable = true);


 };

 extern USART_t XART1, XART2, XART3, XART6;
 extern UART_t XART4, XART5, XART7, XART8;
 static struct {
  pureptr_t operator[](byte id) {
   switch (id) {
   case 1: return (pureptr_t)&XART1;
   case 2: return (pureptr_t)&XART2;
   case 3: return (pureptr_t)&XART3;
   case 4: return (pureptr_t)&XART4;
   case 5: return (pureptr_t)&XART5;
   case 6: return (pureptr_t)&XART6;
   case 7: return (pureptr_t)&XART7;
   case 8: return (pureptr_t)&XART8;
   default: return 0;
   }
  }
  static bool isSync(byte id) {
   return id == 1 || id == 2 || id == 3 || id == 6;
  }
 } XART;

}
# 2 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/../../Device/UART" 2
# 45 "../../../../../SVGN/unisym/inc/cpp\\MCU/ST/STM32F4" 2
# 3 "main.cpp" 2
using namespace uni;
GPIO_Pin& LEDR = GPIOI[5];
GPIO_Pin& LEDG = GPIOI[6];
GPIO_Pin& LEDB = GPIOI[7];
GPIO_Pin& KEY = GPIOH[15];

int main() {
 LEDR.setMode(GPIOMode::OUT_PushPull);
 LEDG.setMode(GPIOMode::OUT_PushPull);
 LEDB.setMode(GPIOMode::OUT_PushPull);
 KEY.setMode(GPIOMode::IN_Floating);
 while (true) {
  LEDB = KEY;
 }
 while (1);
}
