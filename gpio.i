# 1 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 395 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp" 2
# 22 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 1
# 26 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../unisym" 1
# 26 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../unisym"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 27 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../unisym" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/../c/stdinc.h" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/../c/stdinc.h"
extern "C" {




# 1 "../../../../../SVGN/unisym/inc/c/proctrl.h" 1
# 12 "../../../../../SVGN/unisym/inc/c/proctrl.h"
# 1 "../../../../../SVGN/unisym/inc/c/uoption.h" 1
# 13 "../../../../../SVGN/unisym/inc/c/proctrl.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/floating.h" 1
# 36 "../../../../../SVGN/unisym/inc/c/floating.h"
# 1 "../../../../../SVGN/unisym/inc/c/integer.h" 1
# 36 "../../../../../SVGN/unisym/inc/c/integer.h"
# 1 "../../../../../SVGN/unisym/inc/c/archit.h" 1
# 28 "../../../../../SVGN/unisym/inc/c/archit.h"
enum Architecture_t
{
 Architecture_x86,
 Architecture_RISCV64,

 Architecture_x86_64,

 Architecture_ARM,
 Architecture_ARM64,
 Architecture_MIPS,
 Architecture_MIPS64,
 Architecture_RISCV32,
 Architecture_POWERPC64,
 Architecture_POWERPC32,
 Architecture_SPARC64,
 Architecture_SPARC32,

 Architecture_Unknown
};
# 164 "../../../../../SVGN/unisym/inc/c/archit.h"
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 1 3
# 106 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 1 3
# 26 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
# 473 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 700 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\__config" 3
namespace std { inline namespace __2 { }}
# 107 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 2 3
# 110 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 123 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 1 3
# 40 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
      namespace std {

          extern "C" {
# 56 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;


typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;





typedef signed char int_least8_t;
typedef signed short int int_least16_t;
typedef signed int int_least32_t;
typedef signed long long int int_least64_t;


typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long int uint_least64_t;




typedef signed int int_fast8_t;
typedef signed int int_fast16_t;
typedef signed int int_fast32_t;
typedef signed long long int int_fast64_t;


typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long int uint_fast64_t;






typedef signed int intptr_t;
typedef unsigned int uintptr_t;



typedef signed long long intmax_t;
typedef unsigned long long uintmax_t;
# 268 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
         }
      }





      using ::std::int8_t;
      using ::std::int16_t;
      using ::std::int32_t;
      using ::std::int64_t;
      using ::std::uint8_t;
      using ::std::uint16_t;
      using ::std::uint32_t;
      using ::std::uint64_t;
      using ::std::int_least8_t;
      using ::std::int_least16_t;
      using ::std::int_least32_t;
      using ::std::int_least64_t;
      using ::std::uint_least8_t;
      using ::std::uint_least16_t;
      using ::std::uint_least32_t;
      using ::std::uint_least64_t;
      using ::std::int_fast8_t;
      using ::std::int_fast16_t;
      using ::std::int_fast32_t;
      using ::std::int_fast64_t;
      using ::std::uint_fast8_t;
      using ::std::uint_fast16_t;
      using ::std::uint_fast32_t;
      using ::std::uint_fast64_t;
      using ::std::intptr_t;
      using ::std::uintptr_t;
      using ::std::intmax_t;
      using ::std::uintmax_t;
# 124 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stdint.h" 2 3
# 165 "../../../../../SVGN/unisym/inc/c/archit.h" 2

# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 1 3
# 44 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 57 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\limits.h" 1 3
# 58 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\limits.h" 2 3
# 167 "../../../../../SVGN/unisym/inc/c/archit.h" 2

# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 1 3
# 43 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 3


# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 1 3
# 28 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
        namespace std {

        extern "C" {







  typedef signed int ptrdiff_t;







    typedef unsigned int size_t;
# 99 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
         }
      }






      using ::std::size_t;
      using ::std::ptrdiff_t;
# 46 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\stddef.h" 2 3


    typedef __decltype(__nullptr) nullptr_t;
# 169 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 277 "../../../../../SVGN/unisym/inc/c/archit.h"
# 1 "../../../../../SVGN/unisym/inc/c/alice.h" 1
# 35 "../../../../../SVGN/unisym/inc/c/alice.h"
typedef void* pureptr_t;
typedef void(*_tofree_ft)(pureptr_t);
typedef int(*_tocomp_ft)(pureptr_t, pureptr_t);
typedef void(symbol_t)(void);
# 54 "../../../../../SVGN/unisym/inc/c/alice.h"
extern "C++" {
 namespace uni {

  template<typename typed, typename types> inline static typed& cast(types& value) {
   return *(typed*)(&value);
  }
 }
}
# 278 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/call.h" 1
# 279 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 1 "../../../../../SVGN/unisym/inc/c/flag.h" 1
# 31 "../../../../../SVGN/unisym/inc/c/flag.h"
extern struct _aflag_t
{
 unsigned char carry : 1;
 unsigned char autosort : 1;
 unsigned char parity : 1;
 unsigned char signsym : 1;
 unsigned char auxiliary : 1;
 unsigned char one : 1;
 unsigned char zero : 1;
 unsigned char sign : 1;
 unsigned char debug : 1;
 unsigned char interrupt_enable : 1;
 unsigned char direction : 1;
 unsigned char overflow : 1;
 unsigned char io_privilege_level : 2;
 unsigned char nested_task : 1;
 unsigned char fail : 1;

 unsigned char resume : 1;
 unsigned char virtual_8086 : 1;
 unsigned char alignment_check : 1;
 unsigned char virtual_interrupt : 1;
 unsigned char virtual_interrupt_pending : 1;
 unsigned char identification : 1;
 unsigned char : 2;
 unsigned char : 8;
} aflaga;
# 280 "../../../../../SVGN/unisym/inc/c/archit.h" 2
# 37 "../../../../../SVGN/unisym/inc/c/integer.h" 2
# 72 "../../../../../SVGN/unisym/inc/c/integer.h"
typedef unsigned char byte;
typedef unsigned char uint8;
typedef signed char sint8;
typedef int8_t int8;
typedef signed char sbyte;
typedef uint16_t word;
typedef uint16_t uint16;
typedef int16_t sint16;
typedef int16_t int16;
typedef int16_t sword;
typedef uint32_t dword;
typedef uint32_t uint32;
typedef int32_t sint32;
typedef int32_t int32;
typedef int32_t sdword;

 typedef uint64_t qword;
 typedef uint64_t uint64;
 typedef int64_t sint64;
 typedef int64_t int64;
 typedef int64_t sqword;



typedef size_t stduint;
typedef ptrdiff_t stdint ;
typedef ptrdiff_t stdsint;

static const pureptr_t None = (pureptr_t)~(stduint)0;
# 37 "../../../../../SVGN/unisym/inc/c/floating.h" 2






inline static double CastF64FromU0(stduint i) {

 return (double)i;
}
# 14 "../../../../../SVGN/unisym/inc/c/proctrl.h" 2


enum Procontroller_t
{
 PCU_Intel8086,
 PCU_AMD_Ryzen7_5800H_Radeon,

 PCU_Unknown
};
# 45 "../../../../../SVGN/unisym/inc/c/proctrl.h"
 typedef uint32 typedest;
 typedef uint32 typeaddr;
# 33 "../../../../../SVGN/unisym/inc/cpp/../c/stdinc.h" 2


}
# 28 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../unisym" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 29 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../unisym" 2
# 27 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 1
# 23 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h"
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 1 3
# 242 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 251 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 3
# 1 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 1 3
# 222 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
typedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;



extern "C" {


__attribute__((__nothrow__)) intmax_t strtoimax(const char * __restrict ,
                   char ** __restrict , int ) __attribute__((__nonnull__(1)));

__attribute__((__nothrow__)) uintmax_t strtoumax(const char * __restrict ,
                    char ** __restrict , int ) __attribute__((__nonnull__(1)));


__attribute__((__nothrow__)) intmax_t wcstoimax(const wchar_t * __restrict ,
                   wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));
__attribute__((__nothrow__)) uintmax_t wcstoumax(const wchar_t * __restrict ,
                    wchar_t ** __restrict , int ) __attribute__((__nonnull__(1)));

extern __attribute__((__nothrow__)) __attribute__((__const__)) intmax_t imaxabs(intmax_t );





extern __attribute__((__nothrow__)) __attribute__((__const__)) imaxdiv_t imaxdiv(intmax_t , intmax_t );
# 263 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\inttypes.h" 3
}
# 252 "E:\\software\\Keil\\ARM\\ARMCLANG\\Bin\\..\\include\\libcxx\\inttypes.h" 2 3
# 28 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h" 2
# 44 "../../../../../SVGN/unisym/inc/cpp/../c/binary.h"
size_t BitReflect(size_t times, size_t val);


uint64_t BitReflect64(size_t times, uint64_t val);
# 25 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2
# 28 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../reference" 1
# 13 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../reference"
namespace uni {

 class Reference {
  volatile typedest* address;
 public:
  Reference(typeaddr address) : address((volatile typedest*)address) {

  }

  operator typedest() const { return *address; }
  volatile typedest* operator&() const { return address; }

  Reference& operator=(typedest val) { *address = val; return *this; }
  Reference& operator&=(typedest val) { *address &= val; return *this; }
  Reference& operator|=(typedest val) { *address |= val; return *this; }
  Reference& operator^=(typedest val) { *address ^= val; return *this; }

  bool bitof(stduint idx) const { return *address & (1 << idx); }

  void setof(stduint idx, bool val = true) { if (val) *address |= (1 << idx); else rstof(idx); }

  void rstof(stduint idx) { *address &= ~(typedest)(1 << idx); }
 };
}
# 29 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 1
# 27 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt"
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h" 1
# 25 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
typedef void (*Handler_t)(void);
# 214 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
typedef enum {

 IRQ_NonMaskableInt = -14,
 IRQ_MemoryManagement = -12,
 IRQ_BusFault = -11,
 IRQ_UsageFault = -10,
 IRQ_SVCall = -5,
 IRQ_DebugMonitor = -4,
 IRQ_PendSV = -2,
 IRQ_SysTick = -1,

 IRQ_WWDG = 0,
 IRQ_PVD = 1,
 IRQ_TAMP_STAMP = 2,
 IRQ_RTC_WKUP = 3,
 IRQ_FLASH = 4,
 IRQ_RCC = 5,
 IRQ_EXTI0 = 6,
 IRQ_EXTI1 = 7,
 IRQ_EXTI2 = 8,
 IRQ_EXTI3 = 9,
 IRQ_EXTI4 = 10,
 IRQ_DMA1_Stream0 = 11,
 IRQ_DMA1_Stream1 = 12,
 IRQ_DMA1_Stream2 = 13,
 IRQ_DMA1_Stream3 = 14,
 IRQ_DMA1_Stream4 = 15,
 IRQ_DMA1_Stream5 = 16,
 IRQ_DMA1_Stream6 = 17,
 IRQ_ADC = 18,
 IRQ_CAN1_TX = 19,
 IRQ_CAN1_RX0 = 20,
 IRQ_CAN1_RX1 = 21,
 IRQ_CAN1_SCE = 22,
 IRQ_EXTI9_5 = 23,
 IRQ_TIM1_BRK_TIM9 = 24,
 IRQ_TIM1_UP_TIM10 = 25,
 IRQ_TIM1_TRG_COM_TIM11 = 26,
 IRQ_TIM1_CC = 27,
 IRQ_TIM2 = 28,
 IRQ_TIM3 = 29,
 IRQ_TIM4 = 30,
 IRQ_I2C1_EV = 31,
 IRQ_I2C1_ER = 32,
 IRQ_I2C2_EV = 33,
 IRQ_I2C2_ER = 34,
 IRQ_SPI1 = 35,
 IRQ_SPI2 = 36,
 IRQ_USART1 = 37,
 IRQ_USART2 = 38,
 IRQ_USART3 = 39,
 IRQ_EXTI15_10 = 40,
 IRQ_RTC_Alarm = 41,
 IRQ_OTG_FS_WKUP = 42,
 IRQ_TIM8_BRK_TIM12 = 43,
 IRQ_TIM8_UP_TIM13 = 44,
 IRQ_TIM8_TRG_COM_TIM14 = 45,
 IRQ_TIM8_CC = 46,
 IRQ_DMA1_Stream7 = 47,
 IRQ_FSMC = 48,
 IRQ_SDIO = 49,
 IRQ_TIM5 = 50,
 IRQ_SPI3 = 51,
 IRQ_UART4 = 52,
 IRQ_UART5 = 53,
 IRQ_TIM6_DAC = 54,
 IRQ_TIM7 = 55,
 IRQ_DMA2_Stream0 = 56,
 IRQ_DMA2_Stream1 = 57,
 IRQ_DMA2_Stream2 = 58,
 IRQ_DMA2_Stream3 = 59,
 IRQ_DMA2_Stream4 = 60,
 IRQ_ETH = 61,
 IRQ_ETH_WKUP = 62,
 IRQ_CAN2_TX = 63,
 IRQ_CAN2_RX0 = 64,
 IRQ_CAN2_RX1 = 65,
 IRQ_CAN2_SCE = 66,
 IRQ_OTG_FS = 67,
 IRQ_DMA2_Stream5 = 68,
 IRQ_DMA2_Stream6 = 69,
 IRQ_DMA2_Stream7 = 70,
 IRQ_USART6 = 71,
 IRQ_I2C3_EV = 72,
 IRQ_I2C3_ER = 73,
 IRQ_OTG_HS_EP1_OUT = 74,
 IRQ_OTG_HS_EP1_IN = 75,
 IRQ_OTG_HS_WKUP = 76,
 IRQ_OTG_HS = 77,
 IRQ_DCMI = 78,
 IRQ_RNG = 80,
 IRQ_FPU = 81
} Request_t;
# 410 "../../../../../SVGN/unisym/inc/cpp/Device/Interrupt/interrupt_tab.h"
extern "C" {
 extern Handler_t FUNC_EXTI[];
 extern Handler_t FUNC_XART[8];
}
# 28 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 2




# 1 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 1
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 1
# 29 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 2
# 89 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/prochip/CortexM4.h" 1
# 31 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/prochip/CortexM4.h"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/prochip/_COM_CORTEX_M_3_4.h" 1






struct SysCtrlBlock_Map {
 uint32 CPUID;
 uint32 ICSR;
 uint32 VTOR;
 uint32 AIRCR;
 uint32 SCR;
 uint32 CCR;
 uint8 SHP[12U];
 uint32 SHCSR;
 uint32 CFSR;
 uint32 HFSR;
 uint32 DFSR;
 uint32 MMFAR;
 uint32 BFAR;
 uint32 AFSR;
 uint32 PFR[2U];
 uint32 DFR;
 uint32 ADR;
 uint32 MMFR[4U];
 uint32 ISAR[5U];
 uint32 RESERVED0[5U];
 uint32 CPACR;
};
# 32 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/prochip/CortexM4.h" 2
# 90 "../../../../../SVGN/unisym/inc/cpp/Device/NVIC" 2

namespace uni {
 namespace NVICReg {
  typedef enum {
   ISER = 0x000 >> 2,
   ICER = 0x080 >> 2,
   ISPR = 0x100 >> 2,
   ICPR = 0x180 >> 2,
   IABR = 0x200 >> 2,
   IP0 = 0x300 >> 2,
   STIR = 0xE00 >> 2,
  } NVICReg;
 }

 class NVIC_t {
 public:
  Reference operator[](NVICReg::NVICReg idx) {
   return Reference(((0xE000E000UL) + 0x0100UL) + (((stduint)idx) << 2));
  }
  Reference Reflect(NVICReg::NVICReg idx, byte offs = 0) {
   return Reference(((0xE000E000UL) + 0x0100UL) + (((stduint)idx + offs) << 2));
  }
  SysCtrlBlock_Map* scbmap;
  uint32 getPriorityGroup();
  uint8* getTable(stduint idx = 0) { return ((uint8*)&(*this)[NVICReg::IP0]) + idx; }
  void setPriority(Request_t req, uint32 priority);
  void setPriority(Request_t req, uint32 prepriority, uint32 subpriority);
  void setAble(Request_t req, bool ena = true) {
   const stduint req_no = (stduint)req;
   if (!req_no) return;
   if (ena) {
    Reflect(NVICReg::ISER, req_no >> 5UL) = ((uint32_t)1 << (req_no & 0x1FUL));
   }
   else ;
  }

 };


 extern NVIC_t NVIC;
}
# 33 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 1
# 23 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2

# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI" 2


namespace uni {
# 52 "../../../../../SVGN/unisym/inc/cpp/Device/EXTI"
 namespace GPIORupt {
  enum RuptEdge {
   Anyedge,
   Posedge,
   Negedge
  };
 }

 namespace GPIOEvent {
  enum EventEdge {
   OUT_PushPull = 0 << 2,
   Anyedge,
   Posedge,
   Negedge
  };
 }


 class EXTI {
 protected:

 public:
  static Reference MaskInterrupt;
  static Reference MaskEvent;
  static Reference TriggerRising;
  static Reference TriggerFalling;
  static Reference Softrupt;
  static Reference Pending;
 };


}
# 34 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 2
# 1 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO" 1
# 27 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 1
# 23 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary"
# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 34 "../../../../../SVGN/unisym/inc/cpp/cinc"
extern "C" {
# 24 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2

# 1 "../../../../../SVGN/unisym/inc/cpp/cinc" 1
# 41 "../../../../../SVGN/unisym/inc/cpp/cinc"
}
# 26 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../binary" 2
# 28 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO" 2


namespace uni {
# 50 "../../../../../SVGN/unisym/inc/cpp/Device/AFIO"
 class SYSCFG {
 protected:

 public:
  static Reference MEMRM;
  static Reference PMC;
  static Reference ExternInterruptCfgs[4];
  static Reference CMPCR;

 };
 typedef SYSCFG AFIO;



}
# 35 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../interrupt" 2
# 30 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 2

extern "C" {
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/uctype.h" 1
# 55 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/../../c/uctype.h"
extern const unsigned char _tab_tolower[];
extern const unsigned char _tab_toupper[];
# 33 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO" 2
}
# 80 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO"
namespace uni {


 class GeneralPurposeInputOutputPin;
 class GeneralPurposeInputOutputPort;
# 152 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/GPIO"
 namespace GPIOMode {
  enum Mode {

   OUT_PushPull = 0x2,
   OUT_OpenDrain = 0x3,
   OUT_AF_PushPull = 0x4,
   OUT_AF_OpenDrain = 0x5,
   IN_Analog = 0x6,
   IN_Floating = 0x0,
   IN_Pull = 0x1,
   IN_KEPT
  };
 }
 namespace GPIOSpeed {
  enum Speed {
   Atmost_Low = 0,
   Atmost_Medium = 1,
   Atmost_High = 2,
   Atmost_Veryhigh = 3,
  };
 }
 namespace GPIOReg {
  typedef enum {
   MODER = 0, OTYPER, OSPEEDR, PUPDR,
   IDR, ODR, BSRR, LCKR,
   AFRL, AFRH
  } GPIOReg;
 }

 class GeneralPurposeInputOutputPin {
  protected: GeneralPurposeInputOutputPort* parent; uint32 bitposi; bool innput;
 public:
  GeneralPurposeInputOutputPin(GeneralPurposeInputOutputPort* parent = 0, uint32 bitposi = 0) : parent(parent), bitposi(bitposi), innput(true) {}
  bool getInn();
  void setMode(GPIORupt::RuptEdge edg);
  void setMode(GPIOEvent::EventEdge edg);
  void setPull(bool pullup);
  void setInterrupt(Handler_t fn);
  void setInterruptPriority(byte preempt, byte sub_priority);
  void enInterrupt(bool enable = true);
  bool isInput() const;





  void _set_alternate(byte selection);

  GeneralPurposeInputOutputPort& getParent() const; inline byte getID() const { return bitposi; } void setMode(GPIOMode::Mode mod, GPIOSpeed::Speed spd = GPIOSpeed::Atmost_Low, bool autoEnClk = true); void Toggle(); GeneralPurposeInputOutputPin& operator=(bool val); GeneralPurposeInputOutputPin& operator=(const GeneralPurposeInputOutputPin& pin); operator bool() const;
 };

 class GeneralPurposeInputOutputPort {
  stduint baseaddr;
  GeneralPurposeInputOutputPin OutpdPins[16];
  GeneralPurposeInputOutputPin ERR;
  uint32 EnablPosi;
 public:
  Reference ClockPort;
  Reference InnpdPort;
  Reference OutpdPort;

  Reference ModerPort;
  Reference OtypePort;
  Reference SpeedPort;
  Reference PullsPort;

  GeneralPurposeInputOutputPort(uint32 ADDR, uint32 CLK, uint32 Enap = 0);
  void enClock(bool enable = true) {
   (ClockPort) |= ((stduint)1 << EnablPosi);
  }
  GeneralPurposeInputOutputPin& operator[](uint8 pinid);
  Reference operator[](GPIOReg::GPIOReg trt) {
   return Reference(baseaddr + (((stduint)trt) << 2));
  }

  GeneralPurposeInputOutputPort& operator=(uint32 val);

  GeneralPurposeInputOutputPort& operator=(const GeneralPurposeInputOutputPort& pot); operator stduint() const;
 };

 extern GeneralPurposeInputOutputPort GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG;
 extern GeneralPurposeInputOutputPort GPIOH, GPIOI;





 struct GeneralPurposeInputOutput {
  GeneralPurposeInputOutputPort ERR;
  GeneralPurposeInputOutput() : ERR(~0, ~0, ~0) { }
  GeneralPurposeInputOutputPort& operator[](char portid);
  stduint Index(const GeneralPurposeInputOutputPort* port);
 };
 extern GeneralPurposeInputOutput GPIO;



 typedef GeneralPurposeInputOutputPin GPIO_Pin;
 typedef GeneralPurposeInputOutputPort GPIO_Port;
}
# 23 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC" 1
# 32 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCAddress" 1
# 33 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCClock" 1
# 38 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCClock"
namespace uni {
 namespace SysclkSource {
  enum RCCSysclockSource {
   HSI = 0x00000000,
   HSE = 0x00000004,
   PLL = 0x00000008,
   Unknown
  };
 }
}
# 162 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCClock"
namespace uni {


 class RCCSystemClock {
 protected:
  SysclkSource::RCCSysclockSource getSource();
  void setSource(SysclkSource::RCCSysclockSource source);
 public:
  RCCSystemClock() { }
        static SysclkSource::RCCSysclockSource CurrentSource();
  bool setMode(SysclkSource::RCCSysclockSource source = SysclkSource::PLL);
  stduint getFrequency();
 };


}
# 34 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCOscillator" 1
# 31 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCOscillator"
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCPLL" 1
# 107 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCPLL"
namespace uni {
 namespace PLLSource {
  enum PLLSource {
   HSI = 0x00000000,
   HSE = 0x00400000,
   Mask = HSE
  };
 }
 class RCCPLL {
 private:
  void enAble(bool ena = true);
 public:
  bool setMode();
  static bool isReady();
 };
}
# 32 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCOscillator" 2


namespace uni {
 namespace HSEState {
  enum RCCOscillatorHSEState {
   Disable = 0x00000000,
   Enable = (uint32)1 << 16,
   Bypass = ((uint32)1 << 18 | Enable),
  };
 }
}
# 131 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCOscillator"
namespace uni {
 class RCCOscillatorHSE
 {
 protected:
 public:
  bool setMode();
  static bool isReady();
 };
 typedef RCCOscillatorHSE HSE_t;

 class RCCOscillatorHSI
 {
 public:

  static bool isReady();
# 154 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCOscillator"
 };
 typedef RCCOscillatorHSI HSI_t;

}
# 35 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC" 2
# 1 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCPrescaler" 1
# 31 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCPrescaler"
namespace uni {
 class RCCPrescaler {

 };
# 72 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCCPrescaler"
 class RCCAHB : public RCCPrescaler {
 public:

  bool setMode(uint8 divexpo = 0, bool usingPCLK1 = true, bool usingPCLK2 = true);
 };

 class RCCAPB : public RCCPrescaler {
 protected:
  stduint PCLK_ID;
 public:
  RCCAPB(stduint PCLK_ID) : PCLK_ID((PCLK_ID - 1) & 1) {

  }

  bool setMode(uint8 divexpo);

  void enAble(uint8 bitposi) {
   Reference _RCC_APBxENR((PCLK_ID == 1) ? (0x40023800 + 0x44) :
    (0x40023800 + 0x40)
   );
   _RCC_APBxENR.setof(bitposi);
  }
 };



}
# 36 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC" 2
# 136 "../../../../../SVGN/unisym/lib/cpp/Device/../../../inc/cpp/Device/RCC/RCC"
namespace uni {

 extern uint32_t SystemCoreClock;
 extern const uint8_t AHBPrescTable[16];
 extern const uint8_t APBPrescTable[8];

 namespace RCCReg {
  typedef enum {
   CR = 0, PLLCFGR, CFGR, CIR,
   AHB1RSTR, AHB2RSTR, AHB3RSTR, REV00,
   APB1RSTR, APB2RSTR, REV01, REV02,
   AHB1ENR, AHB2ENR, AHB3ENR, REV03,
   APB1ENR, APB2ENR, REV04, REV05,
   AHB1LPENR, AHB2LPENR, AHB3LPENR, REV06,
   APB1LPENR, APB2LPENR, REV07, REV08,
   BDCR, CSR, REV09, REV10,
   SSCGR, PLLI2SCFGR
  } RCCReg;
 }

 class RCC_t {
 protected:
        byte getLatency() {
   Reference _FLASH_ACReg(0x40023C00);
   return (_FLASH_ACReg & 0x7);
  }
        void setLatency(byte FLatency) {
   FLatency &= 0x7;
   Reference _FLASH_ACReg(0x40023C00);
   _FLASH_ACReg = (_FLASH_ACReg & ~(0x7)) | FLatency;
  }
 public:
  RCCOscillatorHSE HSE;



  RCCPLL PLL;
  RCCSystemClock Sysclock;
  RCCAHB AHB;
  RCCAPB APB1, APB2;
  inline Reference operator[](RCCReg::RCCReg idx) { return Reference( 0x40023800 + (((stduint)idx) << 2)); }
  RCC_t() : APB1(1), APB2(2) {}
        bool setFlash(bool decrease = false) {
   stduint FLatency = 5;
   if ((FLatency > getLatency()) ^ decrease)
    setLatency(FLatency);
   return FLatency == getLatency();
  }
  bool setClock(SysclkSource::RCCSysclockSource source);




  stduint getFrequencyHCLK() {
   return SystemCoreClock;
  }
  stduint getFrequencyPCLK1();
  stduint getFrequencyPCLK2();


 };

 extern RCC_t RCC;
}
# 24 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp" 2



namespace uni
{



 static Request_t GPIO_Request_list[16] = {
  IRQ_EXTI0, IRQ_EXTI1, IRQ_EXTI2, IRQ_EXTI3,
  IRQ_EXTI4, IRQ_EXTI9_5, IRQ_EXTI9_5, IRQ_EXTI9_5,
  IRQ_EXTI9_5, IRQ_EXTI9_5, IRQ_EXTI15_10, IRQ_EXTI15_10,
  IRQ_EXTI15_10, IRQ_EXTI15_10, IRQ_EXTI15_10, IRQ_EXTI15_10
 };

 void GeneralPurposeInputOutputPin::setInterrupt(Handler_t fn) {
  FUNC_EXTI[bitposi] = fn;
 }


 void GeneralPurposeInputOutputPin::setInterruptPriority(byte preempt, byte sub_priority) {
  NVIC.setPriority(GPIO_Request_list[bitposi], preempt, sub_priority);
 }


 void GeneralPurposeInputOutputPin::enInterrupt(bool enable) {
  if (enable)
   NVIC.setAble(GPIO_Request_list[bitposi]);
  else ;
 }

 void GeneralPurposeInputOutputPin::setMode(GPIORupt::RuptEdge edg) {
  if (!isInput())
   setMode(GPIOMode::IN_Floating);





  RCC.APB2.enAble(14);


  for(size_t i=0, _LIMIT=(10);i<(_LIMIT);i++);
  Reference& CrtEXTICR = AFIO::ExternInterruptCfgs[bitposi >> 2];
  byte CrtPosi = (bitposi & 0x3) * 4;
  CrtEXTICR = (CrtEXTICR &
   ~(stduint)(0xF << CrtPosi)) |
   (GPIO.Index(parent) << CrtPosi);
  EXTI::TriggerRising.setof(bitposi, edg != GPIORupt::Negedge);
  EXTI::TriggerFalling.setof(bitposi, edg != GPIORupt::Posedge);
  EXTI::MaskInterrupt.setof(bitposi);
 }
# 177 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp"
 GeneralPurposeInputOutputPort::GeneralPurposeInputOutputPort(uint32 ADDR, uint32 CLK, uint32 Enap) :
  baseaddr(ADDR),
  EnablPosi(Enap),
  ClockPort(CLK),
  InnpdPort(0x10 + ADDR),
  OutpdPort(0x14 + ADDR),

  ModerPort(0x00 + ADDR),
  OtypePort(0x04 + ADDR),
  SpeedPort(0x08 + ADDR),
  PullsPort(0x0C + ADDR)


 {
  for(size_t i=0, _LIMIT=((sizeof(OutpdPins)/sizeof(*(OutpdPins))));i<(_LIMIT);i++)
   OutpdPins[i] = GeneralPurposeInputOutputPin(this, i);
 }

 GeneralPurposeInputOutputPort GPIOA(0x40020000, 0x40023830, 0);
 GeneralPurposeInputOutputPort GPIOB(0x40020400, 0x40023830, 1);
 GeneralPurposeInputOutputPort GPIOC(0x40020800, 0x40023830, 2);
 GeneralPurposeInputOutputPort GPIOD(0x40020C00, 0x40023830, 3);
 GeneralPurposeInputOutputPort GPIOE(0x40021000, 0x40023830, 4);
 GeneralPurposeInputOutputPort GPIOF(0x40021400, 0x40023830, 5);
 GeneralPurposeInputOutputPort GPIOG(0x40021800, 0x40023830, 6);
 GeneralPurposeInputOutputPort GPIOH(0x40021C00, 0x40023830, 7);
 GeneralPurposeInputOutputPort GPIOI(0x40022000, 0x40023830, 8);



 static GeneralPurposeInputOutputPort* GPIO_List[] = {
  &GPIOA, &GPIOB, &GPIOC, &GPIOD, &GPIOE, &GPIOF, &GPIOG, &GPIOH, &GPIOI
 };

 GeneralPurposeInputOutputPin::operator bool() const {
  return (innput ? parent->InnpdPort : parent->OutpdPort) & (1 << bitposi);
 }

 GeneralPurposeInputOutputPin& GeneralPurposeInputOutputPin::operator=(bool val) {
  if (innput) return *this;


  if (val)
   (parent->OutpdPort) |= ((stduint)1 << bitposi);
  else
   (parent->OutpdPort) &= ~((stduint)1 << bitposi);
  return *this;
 }

 void GeneralPurposeInputOutputPin::setMode(GPIOMode::Mode mode, GPIOSpeed::Speed speed, bool autoEnClk) {
  if (autoEnClk) parent->enClock();
  parent->ModerPort &= ~(uint32)(0x3 << (bitposi << 1));
  parent->ModerPort |= (((stduint)mode)>>1) << (bitposi << 1);
  if ((stduint)mode & 1)
   (parent->OtypePort) |= ((stduint)1 << bitposi);
  else
   (parent->OtypePort) &= ~((stduint)1 << bitposi);
  parent->SpeedPort &= ~(uint32)(0x3 << (bitposi << 1));
  parent->SpeedPort |= (stduint)speed << (bitposi << 1);
  if (mode == GPIOMode::IN_Floating) parent->PullsPort &= ~(uint32)(0x3 << (bitposi << 1));
  innput = (GPIOMode::IN_Floating == mode) || (GPIOMode::IN_Analog == mode) || (GPIOMode::IN_Pull == mode);

 }

 void GeneralPurposeInputOutputPin::setPull(bool pullup) {
  if (pullup) {
   parent->PullsPort |= 0x1 << (bitposi << 1);
   parent->PullsPort &= ~(uint32)(0x2 << (bitposi << 1));
  }
  else {
   parent->PullsPort |= 0x2 << (bitposi << 1);
   parent->PullsPort &= ~(uint32)(0x1 << (bitposi << 1));
  }
 }

 bool GeneralPurposeInputOutputPin::isInput() const {
  return 0 == (parent->ModerPort &
   (0x3 << ((bitposi & 0xF) * 2)));
 }

 void GeneralPurposeInputOutputPin::Toggle() {
  parent->OutpdPort ^= 1 << bitposi;
 }

 void GeneralPurposeInputOutputPin::_set_alternate(byte selection) {
  selection &= 0xF;
  byte bposi = (bitposi & 0x7) << 2;
  Reference r = parent->operator[](bitposi < 8 ? GPIOReg::AFRL : GPIOReg::AFRH);
  r = (r & ~(stduint)(0xF << bposi)) | (selection << bposi);
 }

 bool GeneralPurposeInputOutputPin::getInn() {
  return getParent()[GPIOReg::IDR].bitof(bitposi);
 }

 GeneralPurposeInputOutputPort::operator stduint() const {
  return (stduint)InnpdPort;
 }
# 332 "../../../../../SVGN/unisym/lib/cpp/Device/GPIO.cpp"
 GeneralPurposeInputOutput GPIO;

 GeneralPurposeInputOutputPort& GeneralPurposeInputOutputPin::getParent() const { return *parent; }

 GeneralPurposeInputOutputPort& GeneralPurposeInputOutput::operator[](char portid) {
  return (((unsigned char)(portid-'A'))<26) ? *(GPIO_List[portid - 'A']) : ERR;
 }

 stduint GeneralPurposeInputOutput::Index(const GeneralPurposeInputOutputPort* port) {
  for(size_t i=0, _LIMIT=((sizeof(GPIO_List)/sizeof(*(GPIO_List))));i<(_LIMIT);i++) {
   if (port == GPIO_List[i]) return i;
  }
  return 0;
 }


 GeneralPurposeInputOutputPort& GeneralPurposeInputOutputPort::operator= (uint32 val) {

  OutpdPort = val;




  return *this;
 }

 GeneralPurposeInputOutputPin& GeneralPurposeInputOutputPort::operator[] (byte pinid) {

  return pinid < (sizeof(OutpdPins)/sizeof(*(OutpdPins))) ? OutpdPins[pinid] : ERR;



 }

 GeneralPurposeInputOutputPin& GeneralPurposeInputOutputPin::operator=(const GeneralPurposeInputOutputPin& pin) {
  if (!parent) {
   parent = pin.parent; bitposi = pin.bitposi; innput = pin.innput;
   return (*this);
  }
  else return (*this) = bool(pin);
 }


 GeneralPurposeInputOutputPort& GeneralPurposeInputOutputPort::operator= (const GeneralPurposeInputOutputPort& pot) {
  return (*this) = stduint(pot);
 }
}
